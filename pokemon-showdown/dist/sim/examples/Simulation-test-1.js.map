{
  "version": 3,
  "sources": ["../../../sim/examples/Simulation-test-1.ts"],
  "sourcesContent": ["/**\n * Battle Stream Example\n * Pokemon Showdown - http://pokemonshowdown.com/\n *\n * Example of how to create AIs battling against each other.\n * Run this using `node build && node dist/sim/examples/simulation-test-1`.\n *\n * @license MIT\n * @author Guangcong Luo <guangcongluo@gmail.com>\n */\n\nimport {BattleStream, getPlayerStreams, Teams} from '..';\nimport {RandomPlayerAI} from '../tools/random-player-ai';\nimport * as fs from 'fs';\nimport {ObjectReadWriteStream} from '../../lib/streams';\nimport {Dex, toID} from '../dex';\nimport {PRNG, PRNGSeed} from '../prng';\nimport {AIOptions, Runner} from '../tools/runner';\nimport { PokemonSet } from '../teams';\nimport { Field } from '../field';\nimport { PassThrough } from 'stream';\n\ninterface trackerPokemon {\n\tspecies: string | undefined\n\tcurrentHp: number\n\tcurrentHpPercent: number\n\tboosts: {}\n\tstats: {}\n\tmoves: [],\n\tn_remaining_mons: number,\n\tsideConditions: {}\n\tfirstTurn: number\n\tprotectCount: number\n\tFutureSightCounter: number\n\tteraType: string | undefined\n}\n\n// a class for tracking useful information about the pokemon currently on the field\n// note this only currently works for singles battles, though could be modified to work for doubles\nclass activeTracker {\n    private _p1_active: trackerPokemon;\n    private _p2_active: trackerPokemon;\n\n    constructor() {\n        this._p1_active = {\n\t\t\tspecies: undefined,\n\t\t\tcurrentHp: 0,\n\t\t\tcurrentHpPercent: 0,\n\t\t\tboosts: {},\n\t\t\tstats: {},\n\t\t\tmoves: [],\n\t\t\tn_remaining_mons: 0,\n\t\t\tsideConditions: {},\n\t\t\tfirstTurn: 0,\n\t\t\tprotectCount: 0,\n\t\t\tFutureSightCounter: 0,\n\t\t\tteraType: undefined\n\t\t  };\n        this._p2_active = {\n\t\t\tspecies: undefined,\n\t\t\tcurrentHp: 0,\n\t\t\tcurrentHpPercent: 0,\n\t\t\tboosts: {},\n\t\t\tstats: {},\n\t\t\tmoves: [],\n\t\t\tn_remaining_mons: 0,\n\t\t\tsideConditions: {},\n\t\t\tfirstTurn: 0,\n\t\t\tprotectCount: 0,\n\t\t\tFutureSightCounter: 0,\n\t\t\tteraType: undefined\n\t\t  };\n    }\n\n    get p1_active(): trackerPokemon{\n        return this._p1_active;\n    }\n\n    set p1_active(pokemon: trackerPokemon) {\n        this._p1_active = pokemon;\n    }\n\n    get p2_active(): trackerPokemon {\n        return this._p2_active;\n    }\n\n    set p2_active(pokemon: trackerPokemon ) {\n        this._p2_active = pokemon;\n    }\n}\n\n\n/**\nStructure of 'request' in random-player-ai, pokemon will have however many pokemon objects as there are on the team\n{\n\tactive: [ { moves: [Array] } ],\n\tside: { name: 'Bot 1', id: 'p1', pokemon: [ [Object], [Object] ], sideConditions: {} } \n} \n\nStructure of request.side.pokemon\n\ti.e. can use request.side.pokemon.condition to get current hp\n{\n\tident: 'p1: Calyrex',\n\tdetails: 'Calyrex-Ice',\n\tcondition: '341/341',\n\tactive: true,\n\tstats: { atk: 429, def: 337, spa: 185, spd: 296, spe: 218 },\n\tmoves: [ 'substitute', 'glaciallance', 'swordsdance', 'leechseed' ],\n\tbaseAbility: 'asoneglastrier',\n\titem: 'leftovers',\n\tpokeball: 'pokeball',\n\tability: 'asoneglastrier'\n\tboosts: { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, accuracy: 0, evasion: 0 },\n\ttrapped: false,\n},\n\nStructure of request.side.foe.pokemon\n[\n  {\n    m: {},\n    baseSpecies: '[Species:darmanitangalar]',\n    species: '[Species:darmanitangalar]',\n    speciesState: { id: 'darmanitangalar' },\n    gender: 'M',\n    dynamaxLevel: 10,\n    gigantamax: false,\n    moveSlots: [ [Object], [Object], [Object], [Object] ],\n    position: 0,\n    details: 'Darmanitan-Galar, M',\n    status: '',\n    statusState: {},\n    volatiles: {},\n    hpType: 'Dark',\n    hpPower: 60,\n    baseHpType: 'Dark',\n    baseHpPower: 60,\n    baseStoredStats: { atk: 379, def: 146, spa: 86, spd: 147, spe: 317, hp: 351 },\n    storedStats: { atk: 379, def: 146, spa: 86, spd: 147, spe: 317 },\n    boosts: { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, accuracy: 0, evasion: 0 },\n    baseAbility: 'gorillatactics',\n    ability: 'gorillatactics',\n    abilityState: { id: 'gorillatactics', choiceLock: '', target: '[Pokemon:p1a]' },\n    item: 'choicescarf',\n    itemState: { id: 'choicescarf', target: '[Pokemon:p1a]' },\n    lastItem: '',\n    usedItemThisTurn: false,\n    ateBerry: false,\n    trapped: false,\n    maybeTrapped: false,\n    maybeDisabled: false,\n    illusion: null,\n    transformed: false,\n    fainted: false,\n    faintQueued: false,\n    subFainted: null,\n    types: [ 'Ice' ],\n    addedType: '',\n    knownType: true,\n    apparentType: 'Ice',\n    switchFlag: false,\n    forceSwitchFlag: false,\n    skipBeforeSwitchOutEventFlag: false,\n    draggedIn: null,\n    newlySwitched: false,\n    beingCalledBack: false,\n    lastMove: null,\n    lastMoveUsed: null,\n    moveThisTurn: '',\n    statsRaisedThisTurn: false,\n    statsLoweredThisTurn: false,\n    hurtThisTurn: null,\n    lastDamage: 0,\n    attackedBy: [],\n    isActive: true,\n    activeTurns: 1,\n    activeMoveActions: 0,\n    previouslySwitchedIn: 1,\n    truantTurn: false,\n    isStarted: true,\n    duringMove: false,\n    weighthg: 1200,\n    speed: 475,\n    abilityOrder: 0,\n    canMegaEvo: null,\n    canUltraBurst: null,\n    canGigantamax: null,\n    maxhp: 351,\n    baseMaxhp: 351,\n    hp: 351,\n    set: {\n      name: 'Darmanitan',\n      species: 'Darmanitan-Galar',\n      item: 'Choice Scarf',\n      ability: 'Gorilla Tactics',\n      gender: '',\n      nature: 'Jolly',\n      evs: [Object],\n      ivs: [Object],\n      level: 100,\n      moves: [Array]\n    }\n  },\n\nStructure of Dex.species.get(\"pokemon name\")\nSpecies {\n  exists: true,\n  tags: [ 'Restricted Legendary' ],\n  num: 898,\n  name: 'Calyrex-Ice',\n  baseSpecies: 'Calyrex',\n  forme: 'Ice',\n  types: [ 'Psychic', 'Ice' ],\n  gender: 'N',\n  baseStats: { hp: 100, atk: 165, def: 150, spa: 85, spd: 130, spe: 50 },\n  abilities: { '0': 'As One (Glastrier)' },\n  heightm: 2.4,\n  weightkg: 809.1,\n  color: 'White',\n  eggGroups: [ 'Undiscovered' ],\n  changesFrom: 'Calyrex',\n}\n\nStructure of request.side.sideConditions\nsideConditions: {\n    toxicspikes: {\n      id: 'toxicspikes',\n      target: [Object],\n      source: [Object],\n      sourceSlot: 'p2a',\n      layers: 1\n    }\n\n/*********************************************************************\n * Class to represent a rule based player AI\n * \toverrides the chooseMove, chooseSwitch, chooseTeamPreview, and shouldDynamax functions in random-player-ai\n *********************************************************************/\nexport class HeuristicsPlayerAI extends RandomPlayerAI {\n\tprivate readonly activeTracker: activeTracker;\n\n\tprivate ENTRY_HAZARDS = [\"spikes\", \"stealthrock\", \"stickyweb\", \"toxicspikes\"]\n\tprivate ANTI_HAZARDS_MOVES = [\"rapidspin\", \"defog\", \"tidyup\"]\n\tprivate SELF_RECOVERY_MOVES = [\"healorder\", \"milkdrink\", \"recover\", \"rest\", \"roost\", \"slackoff\", \"softboiled\"]\n\tprivate WEATHER_SETUP_MOVES = {\"chillyreception\":\"Snow\", \"hail\":\"Hail\", \"raindance\":\"RainDance\", \"sandstorm\":\"Sandstorm\",\n\t\t\"snowscape\":\"Snow\", \"sunnyday\":\"SunnyDay\"}\n\tprivate SOUND_BASED_MOVES = [\"growl\", \"roar\", \"sing\", \"supersonic\", \"screech\", \"snore\", \"healbell\", \"uproar\", \"hypervoice\",\n\t\t\"metalsound\", \"grasswhistle\", \"howl\", \"bugbuzz\", \"chatter\", \"round\", \"echoedvoice\", \"relicsong\", \"snarl\", \"nobleroar\", \n\t\t\"disarmingvoice\", \"partingshot\", \"boomburst\", \"confide\", \"sparklingaria\", \"clangingscales\", \"clangoroussoulblaze\",\n\t\t\"clangoroussoul\", \"overdrive\", \"eeriespell\", \"torchsong\", \"alluringvoice\", \"psychicnoise\"]\n    private SPEED_TIER_COEFICIENT = 0.1\n    private HP_FRACTION_COEFICIENT = 0.4\n    private SWITCH_OUT_MATCHUP_THRESHOLD = -2\n\tprivate SELF_KO_MOVE_MATCHUP_THRESHOLD = 0.3\n\tprivate TRICK_ROOM_THRESHOLD = 85\n\tprivate RECVOERY_MOVE_THRESHOLD = 0.4\n\tprivate ACCURACY_SWITCH_THRESHOLD = -3\n\n\tconstructor(playerStream: ObjectReadWriteStream<string>, options: AIOptions, activeTracker: activeTracker) {\n\t\tsuper(playerStream, options);\n\t\tthis.activeTracker = activeTracker;\n\t}\n\n\t// estimates a given matchup and returns a score\n\tprotected _estimateMatchup(request, nonActiveMon?): number {\n\t\tthis._updateActiveTracker(request)\n\t\tconst mon_opponent = this._getCurrentPlayer(request)\n\t\tvar mon = mon_opponent[0].species!\n\t\tvar opponent = mon_opponent[1].species!\n\t\tif (nonActiveMon) mon = nonActiveMon.details!\n\t\tconst {Dex} = require('pokemon-showdown');\n\t\tlet score = 1;\n    \tscore = this.bestDamageMultiplier(mon, opponent)\n\t\tscore -= this.bestDamageMultiplier(opponent, mon)\n\t\tif (Dex.species.get(mon).baseStats.spe > Dex.species.get(opponent).baseStats.spe) {\n\t\t\tscore += this.SPEED_TIER_COEFICIENT;\n\t\t} else if (Dex.species.get(opponent).baseStats.spe > Dex.species.get(mon).baseStats.spe) {\n\t\t\tscore -= this.SPEED_TIER_COEFICIENT;\n\t\t}\n\t\tif (request.side.id == \"p1\") {\n\t\t\tif (nonActiveMon) score += this._getCurrentHp(nonActiveMon.condition) * this.HP_FRACTION_COEFICIENT;\n\t\t\telse score += this.activeTracker.p1_active!.currentHp * this.HP_FRACTION_COEFICIENT;\n\t\t\tscore -= this.activeTracker.p2_active!.currentHp * this.HP_FRACTION_COEFICIENT;\n\t\t} else {\n\t\t\tif (nonActiveMon) score += this._getCurrentHp(nonActiveMon.condition) * this.HP_FRACTION_COEFICIENT;\n\t\t\telse score += this.activeTracker.p2_active!.currentHp * this.HP_FRACTION_COEFICIENT;\n\t\t\tscore -= this.activeTracker.p1_active!.currentHp * this.HP_FRACTION_COEFICIENT;\n\t\t}\n\t\treturn score;\n\t}\n\n\t// estimate matchup function for team preview\n\tprotected _estimateMatchupTeamPreview(nonActiveMon, nonActiveOpp): number  {\n\t\tconst monName = nonActiveMon.details\n\t\tconst oppName = nonActiveOpp.species\n\t\tconst {Dex} = require('pokemon-showdown');\n\t\tlet score = 1;\n    \tscore = this.bestDamageMultiplier(monName, oppName)\n\t\tscore -= this.bestDamageMultiplier(oppName, monName)\n\t\tif (Dex.species.get(monName).baseStats.spe > Dex.species.get(oppName).baseStats.spe) {\n\t\t\tscore += this.SPEED_TIER_COEFICIENT;\n\t\t} else if (Dex.species.get(oppName).baseStats.spe > Dex.species.get(monName).baseStats.spe) {\n\t\t\tscore -= this.SPEED_TIER_COEFICIENT;\n\t\t}\n\t\t// calculating max hp for opponent since there is no maxHp in dex or currenthp in request.side.foe.pokemon\n\t\tconst oppHp = Math.floor((((2 * Number(Dex.species.get(nonActiveOpp.species).baseStats.hp))\n\t\t\t+ Number(nonActiveOpp.ivs.hp) + Math.floor(Number(nonActiveOpp.evs.hp) / 4) ) * Number(nonActiveOpp.level)) / 100) \n\t\t\t+ Number(nonActiveOpp.level) + 10\n\t\tscore += this._getCurrentHp(nonActiveMon.condition) * this.HP_FRACTION_COEFICIENT;\n\t\tscore -= oppHp * this.HP_FRACTION_COEFICIENT;\n\t\treturn score;\n\t}\n\n\tprotected shouldDynamax(request, canDynamax: boolean): boolean {\n\t\tthis._updateActiveTracker(request)\n\t\tif (canDynamax) {\n\t\t\tconst mon_opponent = this._getCurrentPlayer(request)\n\t\t\tconst mon = mon_opponent[0]\n\t\t\tconst opponent = mon_opponent[1]\n\t\t\t// if active mon is the last full HP mon\n\t\t\tif (\n\t\t\t\trequest.side.pokemon.filter((m) => parseInt(m.condition.split('/')[0], 10) == 1).length == 1\n\t\t\t\t&& mon.currentHp == 1\n\t\t\t) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Matchup advantage and on full hp\n\t\t\tif ((this._estimateMatchup(request)>0) && mon.currentHpPercent == 1 && opponent.currentHpPercent == 1) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// last pokemon\n\t\t\tif (\n\t\t\t\trequest.side.pokemon.filter((m) => Number(this._getHpFraction(m.condition)) != 0).length == 1\n\t\t\t\t&& mon.currentHpPercent == 1\n\t\t\t) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tprotected shouldTera(request, canTerastallize: boolean): boolean {\n\t\tthis._updateActiveTracker(request)\n\t\tif (canTerastallize) {\n\t\t\tconst mon_opponent = this._getCurrentPlayer(request)\n\t\t\tconst mon = mon_opponent[0]\n\t\t\tconst opponent = mon_opponent[1]\n\t\t\t// if active mon is the last full HP mon and tera type has advantage\n\t\t\tif (\n\t\t\t\tthis.bestDamageMultiplier(mon.species!, opponent.species!, false, mon.teraType)\n\t\t\t\t&& request.side.pokemon.filter((m) => parseInt(m.condition.split('/')[0], 10) == 1).length == 1\n\t\t\t\t&& mon.currentHp == 1\n\t\t\t) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// last pokemon and tera type has advantage\n\t\t\tif (\n\t\t\t\tthis.bestDamageMultiplier(mon.species!, opponent.species!, false, mon.teraType)\n\t\t\t\t&& request.side.pokemon.filter((m) => Number(this._getHpFraction(m.condition)) != 0).length == 1\n\t\t\t\t&& mon.currentHpPercent == 1\n\t\t\t) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Matchup disadvantage, tera type has advantage and good hp on both player and opponent\n\t\t\tif ((this._estimateMatchup(request)<0)\n\t\t\t\t&& this.bestDamageMultiplier(mon.species!, opponent.species!, false, mon.teraType)\n\t\t\t\t&& mon.currentHpPercent == 1 && opponent.currentHpPercent >= 0.75)\n\t\t\t{\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tprotected _should_switch_out(request) {\n\t\tthis._updateActiveTracker(request)\n\t\tconst mon_opponent = this._getCurrentPlayer(request)\n\t\tconst mon = mon_opponent[0]\n\t\tconst opponent = mon_opponent[1]\n\t\tconst availableSwitches = (request.side.pokemon).filter((m) => ((m.active == false) && this._getHpFraction(m.condition) != 0))\n\n\t\t// No available switches\n\t\tif (!availableSwitches) return false\n\n\t\t// If there is a decent switch in and not trapped...\n\t\tif (availableSwitches.filter(m => this._estimateMatchup(request) > 0).length && request.side.pokemon.trapped == false) {\n\t\t\t// ...and a 'good' reason to switch out\n\t\t\tif (mon.boosts[\"accuracy\"] <= this.ACCURACY_SWITCH_THRESHOLD) {\n\t\t\t\treturn true\n\t\t\t}\n            if (mon.boosts[\"def\"] <= -3 || mon.boosts[\"spd\"] <= -3) {\n                return true\n\t\t\t}\n\t\t\tif (mon.boosts[\"atk\"] <= -3 && mon.stats[\"atk\"] >= mon.stats[\"spa\"]) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (mon.boosts[\"spa\"] <= -3 && mon.stats[\"atk\"] <= mon.stats[\"spa\"]) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (this._estimateMatchup(request) < this.SWITCH_OUT_MATCHUP_THRESHOLD) {\n                return true\n\t\t\t}\n\t\t}\n\t\tconst activeOpp = request.side.foe.pokemon.filter(mon => mon.isActive == true)[0];\n\t\tif (Object.keys(activeOpp.volatiles).includes(\"perishsong\") || Object.keys(activeOpp.volatiles).includes(\"perish1\")) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tprotected _stat_estimation(mon, stat) {\n\t\t// Stats boosts value\n        if (mon.boosts[stat] > 1) {\n            const  boost = (2 + mon.boosts[stat]) / 2\n\t\t\treturn ((2 * Dex.species.get(mon.species).baseStats[stat] + 31) + 5) * boost\n\t\t} else {\n            const boost = 2 / (2 - mon.boosts[stat])\n\t\t\treturn ((2 * Dex.species.get(mon.species).baseStats[stat] + 31) + 5) * boost\n\t\t}\n\t}\n\n\tprotected chooseMove(request, active, moves: {choice: string, move}[], canDynamax, canTerastallize, possibleMoves): [string, boolean, boolean] {\n\t\tthis._updateActiveTracker(request)\n\t\tconst mon_opponent = this._getCurrentPlayer(request)\n\t\tconst mon = mon_opponent[0]\n\t\tconst opponent = mon_opponent[1]\n\t\t\n\t\t// update protect count if it's on cooldown\n\t\tif (mon.protectCount > 0) {\n\t\t\tmon.protectCount -= 1\n\t\t}\n\n\t\t// update future sight counter if it's been used recently\n\t\tif (mon.FutureSightCounter > 0) {\n\t\t\tmon.FutureSightCounter -= 1\n\t\t}\n\n\t\tconst currentWeather = request.side.pokemon[0].battle.field.weather\n\t\tconst allMoves = possibleMoves\n\n\t\t// if the move is out of pp or is disabled, we ignore it when figuring out what move to use\n\t\tfor (var move of possibleMoves) {\n\t\t\tif (move.pp == 0 || move.disabled == true) {\n\t\t\t\tpossibleMoves = possibleMoves.filter((m) => (m.id || m.move) !== (move.id || move.move));\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Rough estimation of damage ratio\n        const physical_ratio = this._stat_estimation(mon, \"atk\") / this._stat_estimation(opponent, \"def\")\n        const special_ratio = this._stat_estimation(mon, \"spa\") / this._stat_estimation(opponent, \"spd\")\n\n\t\t// list of all side conditions on each player's side\n\t\tconst monSideConditionList = Object.keys(mon.sideConditions).map(move => mon.sideConditions[move].id)\n\t\tconst oppSideConditionList = Object.keys(opponent.sideConditions).map(move => opponent.sideConditions[move].id)\n\n\t\t// if the pokemon has moves and shouldn't switch out, or is the last pokemon left\n\t\tif (possibleMoves && !(this._should_switch_out(request)) \n\t\t|| (request.side.pokemon.filter((m) => Number(this._getHpFraction(m.condition)) != 0).length == 1 && mon.currentHpPercent == 1)) {\n\t\t\tconst n_remaining_mons = mon.n_remaining_mons\n            const n_opp_remaining_mons = opponent.n_remaining_mons\n\n\t\t\t// Fake Out\n\t\t\t\t// If pokemon's first turn out and opponent isn't immune use fake out\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tif ((move.id || move.move) == \"fakeout\" && mon.firstTurn == 1 && !Dex.species.get(opponent.species).types.includes(\"Ghost\")) {\n\t\t\t\t\tmon.firstTurn = 0\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t}\n\t\t\tmon.firstTurn = 0\n\n\t\t\t// Explosion/Self destruct\n\t\t\t\t// use if health < 0.3 and opponent isn't immune\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tif (((move.id || move.move) == \"explosion\" || (move.id || move.move) == \"selfdestruct\") \n\t\t\t\t&& mon.currentHpPercent<this.SELF_KO_MOVE_MATCHUP_THRESHOLD && opponent.currentHpPercent>0.5\n\t\t\t\t&& !Dex.species.get(opponent.species).types.includes(\"Ghost\")) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Deal with non weather related field changing effects\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\t// Tailwind\n\t\t\t\tif ((move.id || move.move) == \"tailwind\" && !monSideConditionList.includes(move.id || move.move)) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t\t// Trick room\n\t\t\t\t\t// if pokemon has trick room and we have at least 3 pokemon slower than the trick room threshold\n\t\t\t\tif ((move.id || move.move) == \"trickroom\" && !monSideConditionList.includes(move.id || move.move)\n\t\t\t\t&& request.side.pokemon.map(m => m.stats.spd).filter(spd => spd <= this.TRICK_ROOM_THRESHOLD).length >= 3) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t\t// Aurora veil\n\t\t\t\tif ((move.id || move.move) == \"auroraveil\" && !monSideConditionList.includes(move.id || move.move)\n\t\t\t\t&& (currentWeather == \"Hail\" || currentWeather == \"Snow\")) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t\t// Light Screen\n\t\t\t\tif ((move.id || move.move) == \"lightscreen\" && !monSideConditionList.includes(move.id || move.move)\n\t\t\t\t&& Dex.species.get(opponent.species).baseStats.spa > Dex.species.get(opponent.species).baseStats.atk) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n                // Reflect\n\t\t\t\tif ((move.id || move.move) == \"reflect\" && !monSideConditionList.includes(move.id || move.move)\n\t\t\t\t&& Dex.species.get(opponent.species).baseStats.atk > Dex.species.get(opponent.species).baseStats.spa) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Entry hazard...\n            for (var move of possibleMoves) {\n                // ...setup\n                if (\n                    n_opp_remaining_mons >= 3\n                    && (this.ENTRY_HAZARDS.includes(move.id || move.move))\n\t\t\t\t\t&& this.ENTRY_HAZARDS.filter(word => oppSideConditionList\n\t\t\t\t\t\t.includes(word)).length === 0 // opponent doesn't already have an entry hazard\n\t\t\t\t) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n                // ...removal\n                else if (\n\t\t\t\t\tn_remaining_mons >= 2\n                    && this.ANTI_HAZARDS_MOVES.includes(move.id || move.move)\n                    && this.ENTRY_HAZARDS.filter(word => monSideConditionList\n\t\t\t\t\t\t.includes(word)).length > 0 // mon has an entry hazard\n                ) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Court Change\n\t\t\t\t// use if either the opponent has some good side condition you want or you want to give them an entry hazard\n\t\t\t\t// and you have no good side conditions to give them, and they have no entry hazards\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tif (\n\t\t\t\t\t(move.id || move.move) == \"courtchange\" \n\t\t\t\t\t&& (!(this.ENTRY_HAZARDS.filter(word => monSideConditionList.includes(word)).length === 0)\n\t\t\t\t\t|| (oppSideConditionList.includes(\"tailwind\") || oppSideConditionList.includes(\"lightscreen\") || oppSideConditionList.includes(\"reflect\"))\n\t\t\t\t\t&& !(monSideConditionList.includes(\"tailwind\") || monSideConditionList.includes(\"lightscreen\") || monSideConditionList.includes(\"reflect\"))\n\t\t\t\t\t&& this.ENTRY_HAZARDS.filter(word => oppSideConditionList.includes(word)).length === 0) ) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Self recovery moves\n\t\t\t\t// use recovery moves if health is less than RECVOERY_MOVE_THRESHOLD\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tif (this.SELF_RECOVERY_MOVES.includes(move.id || move.move) && mon.currentHpPercent < this.RECVOERY_MOVE_THRESHOLD) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Strength sap \n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tif ((move.id || move.move) == \"strengthsap\" && mon.currentHpPercent < 0.5 && Dex.species.get(opponent.species).baseStats.atk > 80) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Weather setup moves\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tif ((move.id || move.move) in this.WEATHER_SETUP_MOVES && currentWeather != this.WEATHER_SETUP_MOVES[(move.id || move.move)].toLowerCase()) {\n\t\t\t\t\t// dealing with Kyogre and Groudon's upgraded weather conditions\n\t\t\t\t\tif (!(currentWeather == \"PrimordialSea\" && this.WEATHER_SETUP_MOVES[(move.id || move.move)]== \"RainDance\")\n\t\t\t\t\t&& !(currentWeather == \"DesolateLand\" && this.WEATHER_SETUP_MOVES[(move.id || move.move)] == \"SunnyDay\")) {\n\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup moves\n            if (mon.currentHpPercent == 1 && this._estimateMatchup(request) > 0) {\n\t\t\t\tconst SETUP_MOVES = JSON.parse(fs.readFileSync(\"../Data/UsefulDatasets/setup_moves.json\", 'utf-8'));\n                for (var move of possibleMoves) {\n\t\t\t\t\t// if move is a setup move and the pokemon has a stat that can be boosted by the move\n\t\t\t\t\tif ((move.id || move.move) in SETUP_MOVES\n\t\t\t\t\t\t&& Math.min(...(Object.keys(this._getNonZeroStats((move.id || move.move)))).map(key => mon.boosts[key])) < 6\n\t\t\t\t\t) {\n\t\t\t\t\t\tif ((move.id || move.move) == \"curse\" && (Dex.species.get(opponent.species).types.includes(\"Ghost\"))){\n\t\t\t\t\t\t\tcontinue; // curse isn't a set up move for ghost types\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Status Inflicting Moves\n\t\t\tconst STATUS_INFLICTING_MOVES = JSON.parse(fs.readFileSync(\"../Data/UsefulDatasets/status_inflicting_moves.json\", 'utf-8'));\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tconst activeOpp = request.side.foe.pokemon.filter(mon => mon.isActive == true)[0];\n\t\t\t\t// make sure the opponent doesn't already have a status condition\n\t\t\t\tif ((\n\t\t\t\t\tObject.keys(activeOpp.volatiles).length === 0 && (!activeOpp.status))\n\t\t\t\t\t&& opponent.currentHpPercent > 0.6 && mon.currentHpPercent > 0.5\n\t\t\t\t\t&& !(request.side.foe.pokemon.ability == (\"leafguard\") && (currentWeather === \"DesolateLand\" || currentWeather === \"SunnyDay\")) // leafguard prevents status conditions in sun\n\t\t\t\t) {\n\t\t\t\t\tconst cond = STATUS_INFLICTING_MOVES[(move.id || move.move)]\n\t\t\t\t\tswitch (cond) {\n\t\t\t\t\t\tcase \"burn\":\n\t\t\t\t\t\t\tif (!Dex.species.get(opponent.species).types.includes(\"Fire\") && Dex.species.get(opponent.species).baseStats.atk > 80) {\n\t\t\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"paralysis\":\n\t\t\t\t\t\t\tif (!Dex.species.get(opponent.species).types.includes(\"Electric\") && Dex.species.get(opponent.species).baseStats.spe > Dex.species.get(mon.species).baseStats.spe) {\n\t\t\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"sleep\":\n\t\t\t\t\t\t\tif (!(Dex.species.get(opponent.species).types.includes(\"Grass\") && (move.id || move.move) === \"spore\" || \"sleeppowder\")\n\t\t\t\t\t\t\t&& Dex.species.get(opponent.species).baseStats.spe > Dex.species.get(mon.species).baseStats.spe\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"insomnia\"\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"sweetveil\"\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"vitalspirit\"\n\t\t\t\t\t\t\t&& ((request.side.foe.pokemon.ability == \"soundproof\") && (move.id || move.move) == this.SOUND_BASED_MOVES.includes(move.id || move.move))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"confusion\":\n\t\t\t\t\t\t\tif (!(Dex.species.get(opponent.species).types.includes(\"Poison\") || Dex.species.get(opponent.species).types.includes(\"Steel\"))\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"magicguard\"\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"owntempo\"\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"oblivious\") {\n\t\t\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"poison\":\n\t\t\t\t\t\t\tif (!(Dex.species.get(opponent.species).types.includes(\"Poison\") || Dex.species.get(opponent.species).types.includes(\"Steel\"))\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"immunity\"\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"magicguard\") {\n\t\t\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"cursed\":\n\t\t\t\t\t\t\tif (Dex.species.get(mon.species).types.includes(\"Ghost\")\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"magicguard\") {\n\t\t\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"leech\":\n\t\t\t\t\t\t\tif (!Dex.species.get(opponent.species).types.includes(\"Grass\")\n\t\t\t\t\t\t\t&& request.side.foe.pokemon.ability != \"magicguard\") {\n\t\t\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n\n\t\t\t// Accuracy lowering moves\n\t\t\t\t// if you have a good matchup, and the opponent isn't below -1 accuracy\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tif (mon.currentHpPercent == 1 && this._estimateMatchup(request) > 0\n\t\t\t\t&& opponent.boosts[\"accuracy\"] > this.ACCURACY_SWITCH_THRESHOLD\n\t\t\t\t&& [\"flash\", \"kinesis\", \"leaftornado\", \"mirrorshot\", \"mudbomb\", \"mudslap\", \"muddywater\", \"nightdaze\", \"octazooka\", \"sandattack\", 'secretpower', 'smokescreen'].includes(move.id || move.move)) {\n\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Protect style moves\n\t\t\t\t// Use if protect wasn't used last turn and opponent is poisoned, burned, or if your mon is leech seeded\n\t\t\tfor (var move of possibleMoves) {\n\t\t\t\tconst activeOpp = request.side.foe.pokemon.filter(mon => mon.isActive == true)[0];\n\t\t\t\tif ([\"protect\", \"banefulbunker\", \"obstruct\", \"craftyshield\", \"detect\", \"quickguard\", \"spikyshield\", \"silktrap\"].includes(move.id || move.move)) {\n\t\t\t\t\t// stall out side conditions\n\t\t\t\t\tif (((oppSideConditionList.includes(\"tailwind\" || \"lightscreen\" || \"reflect\" || \"trickroom\")\n\t\t\t\t\t&& !monSideConditionList.includes(\"tailwind\" || \"lightscreen\" || \"reflect\")) \n\t\t\t\t\t|| (Object.keys(activeOpp.volatiles).includes(\"curse\") || activeOpp.status != '')) // opp has status conditions\n\t\t\t\t\t&& (mon.protectCount == 0) && (request.side.foe.pokemon.ability != \"unseenfist\")) {\n\t\t\t\t\t\tmon.protectCount = 2\n\t\t\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Damage dealing moves\n\t\t\tconst moveValues: { [move: string]: number } = {};\n\t\t\tfor (const move of possibleMoves) {\n\t\t\t\tmoveValues[(move.id || move.move)] = Dex.moves.get(move.id || move.move).basePower\n\t\t\t\t* (Dex.species.get(mon.species).types.includes(Dex.moves.get((move.id || move.move)).type) ? 1.5 : 1)\n\t\t\t\t// * (Dex.moves.get((move.id || move.move)).category === \"Physical\" ? physical_ratio : special_ratio) // This line needs to be commented out if running the bot on a generation before the physical special split was introduced\n\t\t\t\t* Number(Dex.moves.get((move.id || move.move)).accuracy)\n\t\t\t\t* this._expectedHits((move.id || move.move))\n\t\t\t\t* this.bestDamageMultiplier(move.id || move.move, opponent.species!, true);\n\n\t\t\t\t// we handled status moves earlier, ignore them here\n\t\t\t\tif (Dex.moves.get(move.id || move.move).basePower == 0) {\n\t\t\t\t\tmoveValues[(move.id || move.move)] = -100\n\t\t\t\t}\n\n\t\t\t\t// if fakeout wasn't used earlier, it will fail\n\t\t\t\tif ((move.id || move.move) == \"fakeout\") {\n\t\t\t\t\tmoveValues[(move.id || move.move)] = 0\n                }\n\n\t\t\t\t// if selfdestruct wasn't used earlier, don't use it\n\t\t\t\tif ((move.id || move.move) == (\"explosion\" || \"selfdestruct\")) {\n\t\t\t\t\tmoveValues[(move.id || move.move)] = 0\n                }\n\n\t\t\t\t// prioritise sleeptalk if asleep\n\t\t\t\tif ((request.side.pokemon.filter(mon => mon.active == true)[0].status != \"sleep\") && (move.id || move.move) == (\"sleeptalk\") || (move.id || move.move) == (\"dreameater\")) {\n\t\t\t\t\tmoveValues[(move.id || move.move)] += 5\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(request.side.foe.pokemon.ability == \"lightningrod\") && Dex.moves.get((move.id || move.move)).type == \"electric\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"flashfire\") && Dex.moves.get((move.id || move.move)).type == \"fire\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"levitate\") && Dex.moves.get((move.id || move.move)).type == \"ground\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"sapsipper\") && Dex.moves.get((move.id || move.move)).type == \"grass\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"motordrive\") && Dex.moves.get((move.id || move.move)).type == \"electric\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"stormdrain\") && Dex.moves.get((move.id || move.move)).type == \"water\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"voltabsorb\") && Dex.moves.get((move.id || move.move)).type == \"electric\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"waterabsorb\") && Dex.moves.get((move.id || move.move)).type == \"water\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"immunity\") && Dex.moves.get((move.id || move.move)).type == \"poison\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"eartheater\") && Dex.moves.get((move.id || move.move)).type == \"ground\"\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"suctioncup\") && (move.id || move.move) == (\"roar\" || \"whirlwind\")\n\t\t\t\t\t|| (request.side.foe.pokemon.ability == \"soundproof\") && (move.id || move.move) == this.SOUND_BASED_MOVES.includes(move.id || move.move)\n\t\t\t\t\t|| (request.side.pokemon.filter(mon => mon.active == true)[0].status != \"sleep\") && (move.id || move.move) == (\"dreameater\")\n\t\t\t\t) {\n\t\t\t\t\tmoveValues[(move.id || move.move)] = -50; // don't do these\n\t\t\t\t}\n\n\t\t\t\t// don't use future sight if it's still on cooldown\n\t\t\t\tif ((move.id || move.move) == (\"futuresight\") && mon.FutureSightCounter != 0) {\n\t\t\t\t\tmoveValues[(move.id || move.move)] = 0\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tconst bestMoveValue = Math.max(...Object.values(moveValues));\n\t\t\tif (!('recharge' in moveValues)) {\n\t\t\t\tconst bestMove = Object.keys(moveValues).find(m => moveValues[m] === bestMoveValue);\n\n\t\t\t\tif (bestMove == \"futuresight\" && mon.FutureSightCounter == 0) {\n\t\t\t\t\tmon.FutureSightCounter = 3 // 3 because it's decremented before moves are used\n\t\t\t\t}\n\n\t\t\t\tvar should_Dynamax = this.shouldDynamax(request, canDynamax)\n\t\t\t\tvar should_Tera = this.shouldTera(request, canTerastallize)\n\t\t\t\tif (should_Dynamax) {\n\t\t\t\t\treturn [this._getMoveSlot(bestMove!, allMoves), true, false]\n\t\t\t\t} else if (should_Tera) {\n\t\t\t\t\treturn [this._getMoveSlot(bestMove!, allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t\t} else {\n\t\t\t\t\treturn [this._getMoveSlot(bestMove!, allMoves), false, false]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn [\"move 1\", false, false]\n\t\t\t}\n\t\t}\n\n\t\t// healing wish (dealing with it here because you'd only use it if you should switch out anyway)\n\t\tfor (var move of possibleMoves) {\n\t\t\tif ((move.id || move.move) == \"healingwish\" && mon.currentHpPercent<this.SELF_KO_MOVE_MATCHUP_THRESHOLD) {\n\t\t\t\treturn [this._getMoveSlot((move.id || move.move), allMoves), false, this.shouldTera(request, canTerastallize)]\n\t\t\t}\n\t\t}\n\n\t\t// switch out\n\t\tif (this._should_switch_out(request)) {\n\t\t\tconst availableSwitches = (request.side.pokemon).filter((m) => ((m.active == false) && this._getHpFraction(m.condition) != 0))\n\t\t\tif (availableSwitches) {\n\t\t\t\tlet bestEstimation = Math.max(...availableSwitches.map(pokemon => this._estimateMatchup(request, pokemon)))\n\t\t\t\tlet bestMatchup = availableSwitches.find(pokemon => this._estimateMatchup(request, pokemon) === bestEstimation)\n\t\t\t\treturn [\"switch \".concat(this._getPokemonPos(request, bestMatchup)), false, false]\n\t\t\t}\n\t\t}\n\t\tmon.firstTurn = 0\n\t\t// otherwise can't find a good option so use a random move\n\t\treturn [this.prng.sample(moves).choice, false, this.shouldTera(request, canTerastallize)]\n\t}\n\n\t// gets the slot number of the pasased in move\n\tprotected _getMoveSlot(move: string, possibleMoves) {\n\t\tconst bestMoveSlotIndex = possibleMoves.findIndex(item => (item.id || item.move) === move) + 1\n\t\tvar bestMoveSlot\n\t\tif (bestMoveSlotIndex == 1) bestMoveSlot = \"move 1\"\n\t\tif (bestMoveSlotIndex == 2) bestMoveSlot = \"move 2\"\n\t\tif (bestMoveSlotIndex == 3) bestMoveSlot = \"move 3\"\n\t\tif (bestMoveSlotIndex == 4) bestMoveSlot = \"move 4\"\n\t\treturn bestMoveSlot\n\t}\n\n\t// gets the slot number of the bestMatchup pokemon in the team\n\tprotected _getPokemonPos(request, bestMatchup) {\n\t\treturn (request.side.pokemon).filter((pokemon) => (pokemon.details == bestMatchup.details && this._getHpFraction(pokemon.condition) != 0 && pokemon.active == false))[0].position+1\n\t}\n\n\t// returns an approximate number of hits for a given move for estimation purposes\n\tprotected _expectedHits(move: string): number {\n\t\tconst minMaxHits = Dex.moves.get(move).multihit\n\t\tif (move == \"triplekick\" || move == \"tripleaxel\") {\n            //Triple Kick and Triple Axel have an accuracy check for each hit, and also\n            //rise in BP for each hit\n            return 1 + 2 * 0.9 + 3 * 0.81\n\t\t}\n\t\tif (move == \"bonemerang\" || move == \"doublehit\" || move == \"doubleironbash\" || move == \"doublekick\" || move == \"dragondarts\"\n\t\t|| move == \"dualchop\" || move == \"dualwingbeat\" || move == \"geargrind\" || move == \"tachyoncutter\" || move == \"twinbeam\" || move == \"twineedle\") {\n\t\t\t// Moves that always hit twice\n            return 2\n\t\t}\n\t\tif (move == \"surgingstrikes\" || move == \"tripledive\" || move == \"watershuriken\") {\n            // Moves that always hit 3 times\n            return 3\n\t\t}\n\t\tif (move == \"populationbomb\") {\n            // population bomb hits until it misses, 90% accuracy\n            return 7\n\t\t}\n        if (minMaxHits == undefined || minMaxHits[0] == minMaxHits[1]) {\n\t\t\t// non multihit move\n            return 1\n\t\t}\n\t\t// It hits 2-5 times\n\t\treturn (2 + 3) / 3 + (4 + 5) / 6\n\t}\n\n\t// Chooses the best pokemon to switch to\n\tprotected chooseSwitch(request, active: AnyObject | undefined, switches: {slot: number, pokemon: AnyObject}[]): number {\n\t\tthis._updateActiveTracker(request)\n\t\tconst availableSwitches = (request.side.pokemon).filter((m) => ((m.active == false) && this._getHpFraction(m.condition) != 0))\n\t\tif (!availableSwitches) return 1\n\t\tlet bestEstimation = Math.max(...availableSwitches.map(pokemon => this._estimateMatchup(request, pokemon)))\n\t\tlet bestMatchup = availableSwitches.find(pokemon => this._estimateMatchup(request, pokemon) === bestEstimation)\n\t\tthis._getCurrentPlayer(request)[0].firstTurn = 1\n\t\treturn Number(this._getPokemonPos(request, bestMatchup))\n\t}\n\n\tprotected chooseTeamPreview(request, team: AnyObject[]): string {\n\t\tthis._updateActiveTracker(request)\n\t\treturn \"team 1\"; // Uncomment to make the bot choose the best mon based on the opponent's team\n\t\tconst mons = request.side.pokemon\n\t\tconst opponentPokemon = request.side.foe.pokemon.map(m => m.set)\n\t\tvar bestMon\n\t\tvar bestAverage\n\t\tvar matchups\n\t\tvar average\n\t\tfor (var mon of mons) {\n\t\t\tmatchups = opponentPokemon.map(opp => this._estimateMatchupTeamPreview(mon, opp))\n\t\t\taverage = matchups.reduce((total, value) => total + value, 0) / matchups.length\n\t\t\tif (bestAverage == undefined || average > bestAverage) {\n\t\t\t\tbestMon = mon\n\t\t\t\tbestAverage = average\n\t\t\t}\n\t\t}\n\t\t// If you have a pokemon with some setup move that will benefit other pokemon on the team, use that first\n\t\tfor (var mon of mons) {\n\t\t\tfor (var move of mon.moves) {\n\t\t\t\tif ((move.id || move.move) in this.WEATHER_SETUP_MOVES\n\t\t\t\t\t|| (move.id || move.move) in this.ENTRY_HAZARDS\n\t\t\t\t\t|| (move.id || move.move) == \"tailwind\"\n\t\t\t\t\t|| (move.id || move.move) == \"trickroom\"\n\t\t\t\t\t|| (move.id || move.move) == \"auroraveil\"\n\t\t\t\t\t|| (move.id || move.move) == \"lightscreen\"\n\t\t\t\t\t|| (move.id || move.move) == \"reflect\"\n\t\t\t\t) {\n\t\t\t\t\tbestMon = mon\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._getCurrentPlayer(request)[0].firstTurn = 1\n\t\treturn \"team \".concat(bestMon.position+1);\n\t}\n\n\t// TODO this doesn't account for terastalised opponents, and just uses the mon's base types\n\t// returns the type with the best damage multiplier against the opponent\n\tprotected bestDamageMultiplier(attacker: string, defender: string, isMove: boolean = false, teraType: string = \"\"): number {\n\t\tconst typeMatchups = JSON.parse(fs.readFileSync(\"../Data/UsefulDatasets/gen_9_type-chart.json\", 'utf-8'));\n\t\tvar attackerTypes;\n\t\tif (isMove) {\n\t\t\tattackerTypes = [Dex.moves.get(attacker).type, \"???\"]\n\t\t} else {\n\t\t\tattackerTypes = Dex.species.get(attacker).types\n\t\t}\n\t\tif (!(teraType === \"???\") && !(teraType === undefined) && !(teraType === \"\")) {\n\t\t\tattackerTypes = [teraType, \"???\"]\n\t\t}\n\t\tconst defenderTypes = Dex.species.get(defender).types\n\t\tlet multiplier = 1;\n\t\tlet bestMultiplier = 1\n\t\tlet counter = 0\n\t\tfor (const attackerType of attackerTypes) {\n\t\t\tmultiplier = 1;\n\t\t\tfor (const defenderType of defenderTypes) {\n\t\t\t\tif (!(attackerType==\"???\") && !(defenderType==\"???\")\n\t\t\t\t&& !(attackerType==undefined) && !(defenderType==undefined)\n\t\t\t\t&& !(attackerType==\"\") && !(defenderType==\"\") &&\n\t\t\t\ttypeMatchups[attackerType] !== undefined && \n\t\t\t\ttypeMatchups[attackerType][defenderType] !== undefined) {\n\t\t\t\t\tmultiplier *= Number(typeMatchups[attackerType][defenderType]);\n\t\t\t\t} else {\n\t\t\t\t\tmultiplier = -5 // discourage unknown move types\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (counter == 0) {\n\t\t\t\tbestMultiplier = multiplier\n\t\t\t}\n\t\t\tcounter += 1\n\t\t}\n\t\treturn Math.max(multiplier, bestMultiplier);\n\t}\n\n\t// The move options provided by the simulator have been converted from the name\n\t// which we're tracking, so we need to convert them back.\n\tprivate fixMove(m) {\n\t\tconst id = toID(m.move);\n\t\tif (id.startsWith('return')) return 'return';\n\t\tif (id.startsWith('frustration')) return 'frustration';\n\t\tif (id.startsWith('hiddenpower')) return 'hiddenpower';\n\t\treturn id;\n\t}\n\n\t// takes hp in the form '457/457' and returns a decimal representing the amount left (with 1 as full hp and 0 as fainted)\n\tprivate _getHpFraction(condition : string): number {\n\t\tif (condition == \"0 fnt\") return 0\n\t\tconst [numerator, denominator] = condition.split('/' || ' ').map(x => parseInt(x, 10));\n\t\treturn numerator / denominator;\n\t}\n\n\t// takes hp in the form '457/457' and returns the amount of hp left\n\tprivate _getCurrentHp(condition : string): number {\n\t\tif (condition == \"0 fnt\") return 0\n\t\treturn Number(condition.split('/' || ' ')[0]);\n\t}\n\n\t// takes a move name and returns the stats that are boosted by that move\n\tprivate _getNonZeroStats(name: string): { [key: string]: number } {\n\t\tconst SETUP_MOVES = JSON.parse(fs.readFileSync(\"../Data/UsefulDatasets/setup_moves.json\", 'utf-8'));\n\t\tif (name in SETUP_MOVES) {\n\t\t\treturn Object.entries(SETUP_MOVES[name])\n\t\t  \t\t.filter(([, value]) => value !== 0)\n\t\t  \t\t.reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});\n\t\t}\n\t\telse {\n\t\t\treturn {}\n\t\t}\n\t  }\n\n\t// fast way to update activeTracker, should be called before making decisions in choose functions\n\tprivate _updateActiveTracker(request) {\n\t\t// find active player\n\t\tif (request.side.id == \"p1\") {\n\t\t\tvar mon = this.activeTracker.p1_active!\n\t\t} else {\n\t\t\tmon = this.activeTracker.p2_active!\n\t\t}\n\t\t// find active pokemon and update data\n\t\tfor (var pokemon of request.side.pokemon) {\n\t\t\tif (pokemon.active == true) {\n\t\t\t\tmon.species = pokemon.species\n\t\t\t\tmon.currentHp = this._getCurrentHp(pokemon.condition)\n\t\t\t\tmon.currentHpPercent = this._getHpFraction(pokemon.condition)\n\t\t\t\tmon.boosts = pokemon.boosts\n\t\t\t\tmon.stats = pokemon.stats\n\t\t\t\tmon.moves = pokemon.moves\n\t\t\t\tmon.n_remaining_mons = request.side.pokemon.filter((m) => Number(this._getHpFraction(m.condition)) != 0).length\n\t\t\t\tmon.sideConditions = request.side.sideConditions\n\t\t\t\tmon.teraType = pokemon.teraType\n\t\t\t}\n\t\t}\n\t}\n\n\t// returns the current pokemon for the player making the request, and the opponent\n\tprivate _getCurrentPlayer(request) {\n\t\tif (request.side.id == \"p1\") {\n\t\t\tvar mon = this.activeTracker.p1_active!\n\t\t\tvar opponent = this.activeTracker.p2_active!\n\t\t\treturn [mon, opponent]\n\t\t} else {\n\t\t\tmon = this.activeTracker.p2_active!\n\t\t\topponent = this.activeTracker.p1_active!\n\t\t\treturn [mon, opponent]\n\t\t}\n\t}\n}\n\n/*********************************************************************\n * Run Simulation\n *********************************************************************/\nasync function main() {\n\tvar threadNo = process.argv.slice(2)[0]\n\tvar team1No = process.argv.slice(3)[0]\n\tvar team2No = process.argv.slice(4)[0]\n\n\tvar testTeam1 = \"../Data/WorkerFiles/\" + threadNo + \"1.txt\"\n\tvar testTeam2 = \"../Data/WorkerFiles/\" + threadNo + \"2.txt\"\n\n\t// const battleStream = new BattleStream()\n\t// const streams = getPlayerStreams(battleStream);\n\n\tvar f = fs.readFileSync(testTeam1, 'utf8');\n\tvar g = fs.readFileSync(testTeam2, 'utf8');\n\n\t// var team1 = Teams.pack(Teams.import(f))\n\t// var team2 = Teams.pack(Teams.import(g))\n\tvar maybeteam1 = Teams.import(f)\n\tvar maybeteam2 = Teams.import(g)\n\tlet team1: PokemonSet[] | undefined;\n\tlet team2: PokemonSet[] | undefined;\n\tif (maybeteam1 !== null) {\n\t\tteam1 = maybeteam1;\n\t}\n\tif (maybeteam2 !== null) {\n\t\tteam2 = maybeteam2;\n\t}\n\n\tconsole.log(\"[[[[[\")\n\tconsole.log(team1No + \" vs \" + team2No)\n\n\tconst spec = {\n\t\tformatid: \"gen1customgame\",\n\t};\n\tconst dex = Dex.forFormat(spec.formatid);\n\n\t // Set ever pokemon's ability to sopmething that doesn't effect battle fr gen 1 simulations\n     const neutralAbility = 'Illuminate'; // Example ability with no effect in battles\n     function assignNeutralAbilities(team) {\n         if (!team) return;\n         for (let pokemon of team) {\n             pokemon.ability = neutralAbility; // Overwrite each Pok\u00E9mon's ability\n         }\n     }\n     // Assign the neutral ability to all Pok\u00E9mon in both teams\n     assignNeutralAbilities(team1);\n     assignNeutralAbilities(team2);\n\n\tconst tracker = new activeTracker()\n\tconst createAI = (s: ObjectReadWriteStream<string>, o: AIOptions) => new HeuristicsPlayerAI(s, o, tracker);\n\n\ttry {\n\t\t// We run these sequentially instead of async so that the team generator\n\t\t// and the AI can coordinate usage properly.\n\t\tawait new Runner({\n\t\t\tp1options: {team: team1, createAI},\n\t\t\tp2options: {team: team2, createAI},\n\t\t\tformat: spec.formatid,\n\t\t\toutput: true,\n\t\t}).run();\n\t} catch (err) {\n\t\tconsole.error(err);\n\t}\n}\n\nmain();"],
  "mappings": "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",
  "names": ["activeTracker", "Dex", "mon", "move"]
}
